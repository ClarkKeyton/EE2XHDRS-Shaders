//===========================================================================
// Copyright 2003 Mad Doc Software, LLC.  All rights reserved.
// $Header: /EE2X/src/EE2/DbHdrs/DbFormationDefs.h 35    4/27/05 4:42p Mcorthell $
//
// DESCRIPTION:   Formations / They make your mouth turn green
//
// AUTHOR:        Ben Morse
//
//===========================================================================

#ifndef DBFORMATIONDEFS_H
#define DBFORMATIONDEFS_H
#pragma once

#include "HdrMacros.h"

// A DbFormationSlot is a single slot for a formation.
// a slot (-5, 2) would look like this:

// **X***** 
// ********
// *******O ->
// ********
// ********

// Where O is the virtual leader and -> is the direction of the formation.

// Needed for MoveTypeToFormationClass
#include "DbUnitDefEnums.h"
// Needed for ePlayerCivilization
#include "DbPlayerDefs.h"

// A formation class is just an indicator of whether this formation is
// intended for land/water/air units.
ENUM eFormationClass {
	kFormationClass_Land,
	kFormationClass_Water,
	kFormationClass_Air,
	kNumFormationClasses,
};

// No zone can have more than this number.
const int kfMaxNumZoneSlots = 400;

inline eFormationClass MoveTypeToFormationClass(eUnitMoveType in_eMoveType)
{
	switch( in_eMoveType )
	{
	case kUnitMoveType_Foot:
	case kUnitMoveType_FootCitizen:
	case kUnitMoveType_FootSpy:
	case kUnitMoveType_Mounted:
	case kUnitMoveType_Wheeled:
	case kUnitMoveType_WheeledTrade:
	case kUnitMoveType_Mechanized:
	case kUnitMoveType_Projectile:		// projectiles used to be foot, so keeping them in same group
		return kFormationClass_Land;
		
	case kUnitMoveType_NavalShallow:
	case kUnitMoveType_NavalDeep:
		return kFormationClass_Water;
		
	case kUnitMoveType_Air:
		return kFormationClass_Air;
		
	default:
		WARN(( "No valid formation class for movetype %d!", int(in_eMoveType) ));
	}
	return kFormationClass_Land;
}

// A special formation type is used to indicate whether a formation is
// generated by normal slot offsets, or if it's a special formation that
// is generated algorithmically.
ENUM eSpecialFormationType {
	kSpecialFormationType_Normal,		// default - this is a normal formation.
	kSpecialFormationType_Circle,		// this is the circle formation (unused)
	kSpecialFormationType_Phalanx,
	kSpecialFormationType_WaterPhalanx,
	kSpecialFormationType_Column,
	kSpecialFormationType_WaterColumn,
	kSpecialFormationType_Wedge,
	kSpecialFormationType_StaggeredLine,
	kSpecialFormationType_DoubleLine,
	kSpecialFormationType_BeastHorns,	// @MRC @EE2X I'm not making this up.
	kNumSpecialFormationTypes,
};

DATACLASS(DbFormationSlot)
	float m_x;			// x offset from the virtual leader.
	float m_y;			// y offset from the virtual leader.
ENDCLASS

DATACLASS(DbSuperSlotDef)
	LSizedArray<int> m_slotIndexes;		// The (one-based!) indexes of the slots in this superslot.
	USER float m_fXLoc;					// This is precalculated in postload to be the centroid of all the involved slots.
	USER float m_fYLoc;					// This is precalculated in postload to be the centroid of all the involved slots.
	USER float m_fRadius;				// This is precalculated in postload to be the furthest distance to any involved slot.
ENDVARS
	int GetNumSlots();					// returns the number of slots involved in this superslot.
	int GetSlotIndex(int i);			// returns the ith slot involved in this superslot.  i should be 1-based, not 0-based.
ENDCLASS

inline int DbSuperSlotDef::GetNumSlots()
{
	return m_slotIndexes.GetSize();
}

inline int DbSuperSlotDef::GetSlotIndex(int i)
{
	// Remember, they're one-based, not zero-based!
	return m_slotIndexes[i]-1;
}

// A DbFormationZone is a collection of DbFormationSlots that all share
// the same sorting priority.
DATACLASS(DbFormationZone)
	LSizedArray<DC(DbFormationSlot)*> m_Slots;				// The list of slots in this zone.
	LSizedArray<DC(DbSuperSlotDef)*> m_SuperSlots;			// Superslot groupings.
	LSizedArray<DBINDEX(DbUnitTypeAttribute)> m_Prefs;		// The matching order in which to assign slots.
	USER float m_fMinRadius;								// the smallest m_fRadius of any superslot in this zone.
ENDCLASS

// types of special range properties a formation can have
ENUM eFormationRangeProperty {
	kFormationRangeProperty_NoBonus,
	kFormationRangeProperty_PercentBonus,
	kFormationRangeProperty_AllInRangeBonus,
};

//DATACLASS(DbFormationBonus)
//	float m_modifier;		// the combat modifer in question.  1.0 means unmodified.
//	const char *m_against;	// the name of the formation against which this bonus applies.  if NULL, mob.
//	USER int m_iAgainstDBI;	// the formation DB index of the 'against' formation.  -1 if NULL.
//ENDCLASS

// A DbFormationDef is a collection of DbFormationZones comprising a single
// formation.
DATACLASS(DbFormationDef)
	LSizedArray<DC(DbFormationZone)*> m_Zones;		// The list of zones in this formation.
	//LSizedArray<DC(DbFormationBonus)*> m_Bonuses;	// The list of formations against which we get bonuses.
	float m_SpacingScaleFactor;					// The scaling factor.  If unspecified, 1.
	enum eFormationClass m_class;				// the land/water/air class of this formation.
	enum eSpecialFormationType m_specialType;	// if this is a special type, which special type it is.
	enum eFormationRangeProperty m_rangeProperty;	// what kind of range boost do we apply for this formation?
	float m_rangeBoost;							// fraction that we boost the range of all ranged units in this formation 0-1
	float m_speedBoost;							// fraction that we boost the speed of all units in this formation, 0-1
	
	DBINDEX(DbSprite) m_icon;		// sprite db index for sprite for this formation
	DBINDEX(DbWidget) m_button;		// widget db index for creating flyout button for this formation

	int	m_showInUI;								// flag if we want this formation exposed to the UI
												// or not; this is kind of a temporary @HACK
												// and maybe should be removed once the set of
												// formations has been finalized
	// @EE2X @MRC
	// What civs are allowed to use this formation?  If empty, it's allowed by any civ.
	LSizedArray<enum ePlayerCivilization> m_AllowedCivs;	

	// @EE2X @MRC 
	// Some formations give damage bonuses to units when they are in this formation.
	float m_AttackBonus;
	// If specified, only units in this UTA get the attack bonus
	const char* m_AttackBonusMask;
ENDCLASS

DATACLASS(DbFormationCombatBonusInfo)
	float m_column;
	float m_circle;
	float m_wedge;
	float m_phalanx;
	float m_staggeredline;
	float m_doubleline;
	float m_bowed;
	float m_horn;
	float m_crescent;
	float m_watercolumn;
	float m_line;
	float m_convoy;
	float m_blockade;
	float m_airphalanx;
	float m_beastHorns;			// @EE2X @MRC Beast Horns formation
	float m_mob;				// no formation
ENDCLASS

#endif // DBFORMATIONDEFS_H
